https://django.fun/docs/django/ru/3.1/intro/tutorial01/



Выполните в терминале в командной строке cd: смену каталога на тот, в котором вы хотите хранить код проекта, затем запустите следующую команду:


$ django-admin startproject mysite


Это создаст каталог mysite в текущем каталоге. Если этого не произошло, то смотрите Problems running django-admin.



Примечание

Не рекомендуется в качестве названия проекта названия встроенных компонентов Python или Django. Это значит, что следует избегать использования таких имен,
как django (будет конфликт с самим фреймворком) или test (будет конфликтовать со стандартным пакетом Python).



Где этот код должен находится?

Если бэкграунд написан на простом старом PHP (без использования современных фреймворков), вы, вероятно, привыкли размещать код
в корневом каталоге веб-сервера (например, /var/www). С Джанго так лучше не делать. Не стоит помещать какой-либо
Python код в корневой каталог веб-сервера, потому что существует риск, что он может стать доступным для просмотра.
Это не очень хорошо для безопасности сервера.

Размещайте свой код в каком-либо каталоге вне корневого каталога сервера, например /home/mycode.




Давайте посмотрим на результат выполнения команды startproject:



mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
		
		
		
Разберем, для чего нужны эти файлы и каталоги:

Внешний корневой каталог mysite/ — это контейнер для вашего проекта. Его имя не имеет значения для Джанго; Вы можете переименовать его на что угодно.

manage.py: утилита, позволяющая взаимодействовать с проектом различными способами. Вы можете прочитать все подробности о manage.py в django-admin and manage.py.

Внутренний каталог mysite/ это Python модуль вашего проекта. Его название вы будете использовать для импорта чего-либо из этого модуля (например, mysite.urls).

mysite/__init__.py: пустой файл, который сообщает Python, что этот каталог должен рассматриваться как пакет Python’а.
Если вы новичок в Python, прочитайте больше о пакетах в официальной документации Python.

mysite/settings.py: Конфигурация и настройки проекта Django. В Django settings рассказано все о том, как работают настройки.

mysite/urls.py: указание URL проекта на Django, можно сказать, что это «оглавление» вашего проекта. Прочитайте больше информации о URL в Диспетчер URL.

mysite/asgi.py: точка входа для ASGI-совместимых веб-серверов для обслуживания вашего проекта.
Смотрите /howto/deploy/asgi/index для более подробной информации, а также документацию по ASGI

mysite/wsgi.py: Точка входа для WSGI совместимых веб-серверов для работы с проектом. Смотрите How to deploy with WSGI для уточнения деталей работы.	



__________________________________________________________________________________________________________________________________________________




__________________________________________________________________________________________________________________________________________________





Сервер разработки¶
Давайте проверим, работает ли ваш проект Django. Перейдите во внешний каталог mysite, если вы этого еще не сделали, и выполните следующие команды:

/ 
$ python manage.py runserver
Вы увидите следующий вывод в командной строке:

Performing system checks...

System check identified no issues (0 silenced).

You have unapplied migrations; your app may not work properly until they are applied.
Run 'python manage.py migrate' to apply them.

марта 12, 2021 - 15:50:53
Django version 3.1, using settings 'mysite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.



Примечание

Пока игнорируйте предупреждение о непримененных миграциях базы данных; мы разберемся с базой данных в ближайшее время.	




__________________________________________________________________________________________________________________________________________________


Вы запустили сервер разработки Django: облегченный веб-сервер, написанный исключительно на Python.
Мы включили его в Django, чтобы можно было быстро разрабатывать проект, не занимаясь настройкой рабочего сервера, такого как Apache,
до тех пор, пока вы не будете готовы к работе.

Сейчас самое время отметить: не используйте этот сервер во всем, что напоминает производственную среду.
Он предназначен только для использования при разработке. (Мы занимаемся созданием веб-фреймворков, а не веб-серверов.)

Теперь, когда запущен сервер, откройте в браузере страницу с адресом http://127.0.0.1:8000/. Вы должны увидеть страницу «Congratulations!» с взлетающей ракетой.
Всё работает!




__________________________________________________________________________________________________________________________________________________



Смена порта

По умолчанию команда runserver запускает сервер разработки на внутреннем IP адресе с портом 8000.

Для смены порта передайте его аргументом в командной строке. Например, эта команда запускает сервер на порту 8080:

/ 
$ python manage.py runserver 8080
Для изменения IP адреса сервера, передайте его вместе с портом.
Например, чтобы использовать все доступные публичные IP-адреса (что полезно, если вы работаете с Vagrant или хотите показать свою работу
на других компьютерах в сети), используйте:

/ 
$ python manage.py runserver 0:8000
0 это сокращение для 0.0.0.0. Полная документация по серверу разработки находится в руководстве runserver.

Автоматическая перезагрузка runserver

Сервер разработки автоматически перезагружает код Python для каждого запроса по мере необходимости.
Вам не нужно перезагружать сервер, чтобы изменения в коде вступили в силу. Однако некоторые действия, такие как добавление файлов,
в эти условия не входят, поэтому вам придется перезапустить сервер в этих случаях.



__________________________________________________________________________________________________________________________________________________




Создание приложения Polls¶
Теперь, когда ваше окружение - «проект» - настроено, вы можете приступить к дальнейшей работе.

Каждое приложение, которое вы пишете в Django, состоит из пакета Python, который следует определенному соглашению. Django поставляется с утилитой, которая автоматически генерирует базовую структуру каталогов приложения, поэтому вы можете сосредоточиться на написании кода, а не на создании каталогов.

Проекты и приложения

В чем разница между проектом и приложением? Приложение - это веб-приложение, которое что-то делает, например, система Weblog, база данных публичных записей или небольшое приложение для опроса. Проект - это набор настроек и приложений для определенного сайта. Проект может содержать несколько приложений. Приложение может быть в нескольких проектах.

Ваши приложения могут находится где угодно в Python path. В этом руководстве мы создадим наше приложение для опроса в том же каталоге, что и ваш файл manage.py, чтобы его можно было импортировать как собственный модуль верхнего уровня, а не как подмодуль mysite.

Чтобы создать приложение, убедитесь, что вы находитесь в том же каталоге, что и manage.py, и введите следующую команду:



$ python manage.py startapp polls



__________________________________________________________________________________________________________________________________________________


Это создаст каталог polls, который выглядит так:

polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
	
	
В этой структуре каталогов будет размещено приложение опроса.


__________________________________________________________________________________________________________________________________________________


Написание первого представления¶
Давайте напишем первое представление (view). Откройте файл polls/views.py и вставьте в него следующий код Python:


polls/views.py¶
from django.http import HttpResponse


def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")
	
	
	
Это самое простое представление, возможное в Django. Чтобы вызвать представление, нам нужно сопоставить его с URL - и для этого нам нужен URLconf.

Чтобы создать URLconf в каталоге polls, создайте файл с именем urls.py. Ваш каталог с приложением должен выглядеть примерно так:


polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    urls.py
    views.py
	
	
В файл polls/urls.py добавьте следующий код:



polls/urls.py¶
from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
]



__________________________________________________________________________________________________________________________________________________



__________________________________________________________________________________________________________________________________________________




Следующим шагом является указание корневого URLconf на модуль polls.urls. В mysite/urls.py добавьте импорт django.urls.include и вставьте include() в список` urlpatterns`, у вас должно получиться так:


mysite/urls.py¶
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('polls/', include('polls.urls')),
    path('admin/', admin.site.urls),
]



Функция include() позволяет ссылаться на другие URLconfs. Всякий раз, когда Django встречает include(), он отсекает любую часть URL-адреса, совпадающую с этой точкой, и отправляет оставшуюся строку во включенный URLconf для дальнейшей обработки.

Идея, стоящая за include(), состоит в том, чтобы упростить добавление и воспроизведение URL-адресов. Так как опросы находятся в их собственном URLconf(polls/urls.py), их можно поместить в «/polls/», или в «/fun_polls/», или в «/content/polls/», или по любому другому корневому пути, и приложение все равно будет работать.

Когда использовать include()

Вы всегда должны использовать include() при включении других шаблонов URL. admin.site.urls - единственное исключение из этого.




__________________________________________________________________________________________________________________________________________________



Теперь вы подключили представление index к URLconf. Убедитесь, что он работает с помощью следующей команды:

/ 
$ python manage.py runserver
Перейдя в браузере по адресу http://localhost:8000/polls/, вы должны увидеть текст «Hello, world. You’re at the polls index.», который вы определили в представлении index.

Страница не найдена?

Если вы получили страницу с ошибкой, убедитесь, что переходите на http://localhost:8000/polls/, а не на http://localhost:8000/.


__________________________________________________________________________________________________________________________________________________




Функция path() передает четыре аргумента, два обязательных: route и view, и два необязательных: kwargs и name. На данный момент стоит рассмотреть, для чего эти аргументы.

path(), аргумент route¶
route - строка, содержащая шаблон URL. При обработке запроса Django начинается с первого шаблона в urlpatterns и пробирается вниз по списку, сравнивая запрошенный URL с каждым шаблоном, пока не найдет тот, который соответствует.

Шаблоны не выполняют поиск параметров GET и POST или имени домена. Например, в запросе к https://www.example.com/myapp/, URLconf будет искать myapp/. В запросе к https://www.example.com/myapp/?Page=3, URLconf также будет искать только myapp/.



__________________________________________________________________________________________________________________________________________________




path(), аргумент view¶
Когда Django находит соответствующий шаблон, он вызывает указанную функцию представления с объектом HttpRequest в качестве первого аргумента и любые «захваченные» значения из маршрута в качестве аргументов ключевого слова. Мы приведем пример этого чуть позже.


path(), аргумент kwargs¶
Произвольные ключевые аргументы могут быть переданы в словаре в целевое представление. Мы не собираемся использовать эту функцию Django в этом уроке.


path(), аргумент name¶
Присвоение имени URL-адресу позволяет вам однозначно ссылаться на него из других мест Django, особенно из шаблонов. Эта мощная функция позволяет вам вносить глобальные изменения в шаблоны URL вашего проекта, касаясь только одного файла.


Когда вы освоитесь с основами запросов и ответов, прочитайте вторую часть этого руководства, чтобы начать работу с базой данных.






__________________________________________________________________________________________________________________________________________________




Создание первого приложения на Django, часть 2¶




Этот учебник начинается с момента, на которым мы остановились в Tutorial 1 остановился. Здесь мы настроим базу данных, создадим первую модель
и быстро познакомимся с автоматически генерируемым сайтом администрирования Django.



Настройка базы данных¶
Теперь откройте mysite/settings.py. Это обычный модуль Python с переменными уровня модуля, представляющими настройки Django.


По умолчанию в конфигурации используется SQLite. Если вы новичок в базах данных или просто хотите попробовать Django, это самый простой выбор.
SQLite включен в Python, поэтому вам не нужно устанавливать что-либо еще для поддержки вашей базы данных. Однако при запуске первого реального проекта
вы можете использовать более масштабируемую базу данных, такую как PostgreSQL, чтобы избежать проблем с переключением баз данных в будущем.

Если вы хотите использовать другую базу данных, установите соответствующую bindings и измените следующие ключи в параметре DATABASES 'default',
чтобы он соответствовал настройкам соединения с вашей базой данных:


ENGINE - 'django.db.backends.sqlite3', 'django.db.backends.postgresql', 'django.db.backends.mysql', или 'django.db.backends.oracle'.
Другие бэкенды также доступны.

NAME - название вашей базы данных. Если вы используете SQLite, база данных будет файлом на вашем компьютере; в этом случае NAME должен
быть полным абсолютным путем, включая имя файла этого файла. Значение по умолчанию BASE_DIR/'db.sqlite3' сохранит файл в каталоге вашего проекта.

Если вы не используете SQLite в качестве базы данных, необходимо добавить дополнительные настройки, такие как USER, PASSWORD и HOST.
Для получения дополнительной информации смотрите справочную документацию для DATABASES.

Для баз данных, отличных от SQLite

Если вы используете базу данных отличную от SQLite, убедитесь, что создали базу данных к этому моменту.
Это делается с помощью команды «CREATE DATABASE database_name;» в интерактивной консоли базы данных.

Также убедитесь, что пользователь базы данных, указанный в mysite/settings.py, имеет права на создание базы данных.
Это позволяет автоматически создавать test database, которая понадобится в следующем уроке.

Если вы используете SQLite, вам не нужно ничего создавать заранее - файл базы данных будет создан автоматически, когда в этом возникнет необходимость.




__________________________________________________________________________________________________________________________________________________



__________________________________________________________________________________________________________________________________________________




Во время редактирования mysite/settings.py, установите TIME_ZONE в свой часовой пояс.

Также обратите внимание на параметр INSTALLED_APPS в верхней части файла. Он содержит имена всех приложений Django,
которые активированы в этом экземпляре проекта Django. Приложения могут использоваться в нескольких проектах, и вы можете упаковывать и
распространять их для использования другими разработчиками в своих проектах.

По умолчанию INSTALLED_APPS содержит следующие приложения, все из которых поставляются с Django:

django.contrib.admin - администраторская часть сайта. Вскоре мы будем ее использовать.

django.contrib.auth - система аутентификации.

django.contrib.contenttypes - фреймворк типов данных.

django.contrib.sessions – фреймвор сессий.

django.contrib.messages – фреймворк сообщений.

django.contrib.staticfiles – фреймворк для работы со статическими файлами.

Эти приложения включены по умолчанию для удобства для большинства базовых задач.

Некоторые из этих приложений используют хотя бы одну таблицу базы данных, поэтому нам необходимо создать таблицы в базе данных,
прежде чем мы сможем их использовать. Для этого выполните следующую команду:

/ 
$ python manage.py migrate




__________________________________________________________________________________________________________________________________________________


Команда migrate просматривает настройку INSTALLED_APPS и создает все необходимые таблицы базы данных в соответствии с настройками
базы данных в вашем файле mysite/settings.py и миграциями базы данных, поставляемыми с приложением (мы рассмотрим их позже).

Вы увидите сообщение для каждой применимой миграции. Если вам интересно, запустите клиент командной строки для вашей базы данных и
введите \dt (PostgreSQL), SHOW TABLES; (MariaDB, MySQL), .schema (SQLite), или SELECT TABLE_NAME FROM USER_TABLES; (Oracle) для отображения таблиц,
созданных Django.

Для минималистов

Как мы уже говорили выше, стандартные приложения включены для общего случая, но они нужны не всем. Если вам не нужны какие-либо или все из них,
не стесняйтесь комментировать или удалять соответствующие строки из INSTALLED_APPS перед запуском migrate. Команда migrate запускает миграцию
только для приложений в INSTALLED_APPS.




__________________________________________________________________________________________________________________________________________________




Создание моделей¶
Теперь мы определим ваши модели – по сути, структуру вашей базы данных с дополнительными метаданными.

Философия

Модель – это единственный, достоверный источник правды о ваших данных. Он содержит основные поля и поведение данных, которые вы храните.
Django придерживается Принцип DRY.
Цель состоит в том, чтобы определить вашу модель данных в одном месте и автоматически извлекать из нее информацию.

Это включает в себя миграции - в отличие от Ruby On Rails, например, миграции полностью происходят из файла ваших моделей и, по сути,
представляют собой историю, которую Django может пролистать, чтобы обновить схему вашей базы данных, чтобы она соответствовала вашим текущим моделям.




__________________________________________________________________________________________________________________________________________________




__________________________________________________________________________________________________________________________________________________




В нашем приложении для опроса мы создадим две модели: Question и Choice. Question содержит вопрос и дату публикации.
Choice содержит два поля: текст выбора и подсчет голосов. Каждый Choice связан с Question.

Эти понятия представлены классами Python. Отредактируйте файл polls/models.py так, чтобы он выглядел следующим образом:



polls/models.py¶
from django.db import models


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
	
	
	
Здесь каждая модель представлена классом, который подкласс django.db.models.Model. Каждая модель имеет несколько переменных класса,
каждая из которых представляет поле базы данных в модели.

Каждое поле представлено экземпляром класса Field - например, CharField для символьных полей и DateTimeField для datetime.
Это сообщает Django, какой тип данных содержит каждое поле.

Имя каждого экземпляра Field (например, question_text или pub_date) – это имя поля в машинно-удобном формате.
Вы будете использовать это значение в своем коде Python, а ваша база данных будет использовать его в качестве имени столбца.

Вы можете использовать необязательный первый позиционный аргумент для Field для обозначения понятного человеку названия.
Это используется в паре интроспективных частей Django, и дублируется как документация. Если это поле не указано,
Django будет использовать машиночитаемое имя. В этом примере мы определили только удобочитаемое имя для Question.pub_date.
Для всех других полей в этой модели, машиночитаемое имя поля будет достаточно в качестве его удобочитаемого имени.

Некоторые классы Field имеют обязательные аргументы. CharField, например, требует, чтобы вы передали ему аргумент max_length.
Это используется не только в схеме базы данных, но и при проверке, как мы скоро увидим.

Field также может иметь различные необязательные аргументы. В этом случае мы установили для default значение voice в 0.

Наконец, обратите внимание, что связь определена с использованием ForeignKey. Это говорит Django, что каждый Choice связан с одним Question.
Django поддерживает все общие отношения базы данных: многие-к-одному, многие-ко-многим и один-к-одному.



__________________________________________________________________________________________________________________________________________________




Активация моделей¶
Этот небольшой кусочек кода модели дает Django много информации. С его помощью Django может:

Создать схему базы данных (оператор CREATE TABLE) для этого приложения.
Создать API доступа к базе данных Python для доступа к объектам Question и Choice.
Но сначала нам нужно сообщить нашему проекту, что установлено приложение polls.

Философия

Приложения Django являются «подключаемыми»: вы можете использовать приложение в нескольких проектах и распространять приложения, потому что они не должны
быть привязаны к конкретной установке Django.




__________________________________________________________________________________________________________________________________________________




Чтобы включить приложение в наш проект, нужно добавить ссылку на его класс конфигурации в настройке INSTALLED_APPS.
Класс PlayersConfig находится в файле polls/apps.py, поэтому его путь - 'polls.apps.PollsConfig'. Отредактируйте файл mysite/settings.py и
добавьте этот путь в параметр INSTALLED_APPS. Это будет выглядеть так:



mysite/settings.py¶
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]


Теперь Django знает, как подключить приложение polls. Давайте запустим другую команду:

/ 
$ python manage.py makemigrations polls
Вы должны увидеть что-то похожее на следующее:

Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Question
    - Create model Choice




__________________________________________________________________________________________________________________________________________________



__________________________________________________________________________________________________________________________________________________






Запустив makemigrations, вы сообщаете Django, что внесли некоторые изменения в свои модели (в данном случае вы сделали новые) и хотите,
чтобы изменения были сохранены как * миграция*.



Миграции - это то, как Django хранит изменения в ваших моделях (и, следовательно, в вашей схеме базы данных) - это файлы на диске.
Вы можете прочитать миграцию для своей новой модели, если хотите. Это файл polls/migrations/0001_initial.py.
Не волнуйтесь, от вас не ожидают, что вы будете читать их каждый раз, когда Django их создает, но они предназначены для редактирования человеком,
если вы хотите вручную что-то изменить.



Есть команда, которая будет запускать миграции для вас и автоматически управлять схемой вашей базы данных - она называется migrate,
и мы вскоре к ней подойдем - но сначала давайте посмотрим, какой SQL будет выполняться этой миграцией. Команда sqlmigrate принимает
имена миграции и возвращает их SQL:




/ 
$ python manage.py sqlmigrate polls 0001
Вы должны увидеть нечто похожее на следующее (мы переформатировали его для удобства чтения):

BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" serial NOT NULL PRIMARY KEY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" serial NOT NULL PRIMARY KEY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" integer NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;






__________________________________________________________________________________________________________________________________________________




__________________________________________________________________________________________________________________________________________________




Обратите внимание на следующее:



Точный вывод будет зависеть от базы данных, которую вы используете. Пример выше создан для PostgreSQL.


Имена таблиц автоматически генерируются путем объединения названия приложения (polls) и названия модели в нижнем регистре - question и choice.
(Вы можете переопределить это поведение.)

Первичные ключи (идентификаторы) добавляются автоматически. (Вы можете переопределить это тоже.)

По соглашению, Django добавляет "_id" к имени поля внешнего ключа. (Да, вы также можете переопределить это.)

Отношение внешнего ключа становится явным с помощью ограничения FOREIGN KEY. Не беспокойтесь о деталях DEFERRABLE; оно говорит PostgreSQL
не применять внешний ключ до конца транзакции.

Он адаптирован к используемой вами базе данных, поэтому обрабатываются специфичные для базы данных типы полей, такие как auto_increment (MySQL),
serial (PostgreSQL) или integer primary key autoincrement (SQLite) для вас автоматически. То же самое касается экранирования имен полей - например,
использование двойных или одинарных кавычек.

Команда sqlmigrate на самом деле не запускает миграцию в вашей базе данных - она просто выводит ее на экран, чтобы вы могли увидеть,
какой SQL Django считает необходимым. Это полезно для проверки того, что собирается делать Django, или если у вас есть администраторы баз данных,
которым требуются сценарии SQL для изменений.


Если вам интересно, вы также можете запустить python manage.py check. Эта команда проверяет любые проблемы в вашем проекте,
не делая миграции или касаясь базы данных.


Теперь запустите migrate еще раз, чтобы создать эти таблицы моделей в вашей базе данных:


/ 
$ python manage.py migrate

Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Rendering model states... DONE
  Applying polls.0001_initial... OK
  
  
  


__________________________________________________________________________________________________________________________________________________




Команда migrate берет все миграции, которые не были применены (Django отслеживает, какие из них применены, используя специальную
таблицу в вашей базе данных под названием django_migrations) и запускает их в вашей базе данных - по сути, синхронизируя изменения,
которые вы внесли в свои модели с помощью схемы в базе данных.



Миграции очень мощны и позволяют вам со временем менять свои модели по мере разработки проекта, без необходимости удалять
вашу базу данных или таблицы и создавать новые - она специализируется на обновлении вашей базы данных в реальном времени,
без потери данных. Мы рассмотрим их более подробно в следующей части руководства, но сейчас вспомним трехэтапное руководство по внесению изменений в модель:


Изменение модели (models.py).

Запуск команды python manage.py makemigrations для создания миграций этих изменений

Выполнение команды python manage.py migrate для применения этих изменений в базе данных.

Причина того, что существуют отдельные команды для создания и применения миграций, заключается в том,
что вы фиксируете миграции в своей системе контроля версий и отправляете их вместе с вашим приложением; они не только облегчают вашу разработку,
они также могут использоваться другими разработчиками и в производстве.


Прочтите документацию django-admin для получения полной информации о том, что может сделать утилита manage.py.




__________________________________________________________________________________________________________________________________________________




Знакомство с API¶
Теперь давайте перейдем к интерактивной оболочке Python и поиграемся с API, предоставляемым Django. Чтобы вызвать оболочку Python, используйте эту команду:

/ 
$ python manage.py shell
Мы используем это вместо простого ввода «python», потому что manage.py устанавливает переменную окружения
DJANGO_SETTINGS_MODULE, которая дает Django путь импорта Python до вашего mysite/settings.py файла.



Попав в оболочку, изучите API базы данных:

>>> from polls.models import Choice, Question  # Import the model classes we just wrote.


# No questions are in the system yet.
>>> Question.objects.all()
<QuerySet []>


# Create a new Question.
# Support for time zones is enabled in the default settings file, so
# Django expects a datetime with tzinfo for pub_date. Use timezone.now()
# instead of datetime.datetime.now() and it will do the right thing.
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())

# Save the object into the database. You have to call save() explicitly.
>>> q.save()

# Now it has an ID.
>>> q.id
1

# Access model field values via Python attributes.
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)

# Change values by changing the attributes, then calling save().
>>> q.question_text = "What's up?"
>>> q.save()

# objects.all() displays all the questions in the database.
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>]>




__________________________________________________________________________________________________________________________________________________




__________________________________________________________________________________________________________________________________________________




Подождите минуту. <Question: Question object (1)> не является полезным представлением этого объекта.
Давайте исправим, отредактировав модель Question (в файле polls/models.py) и добавив метод __str__() в оба Question и Choice`:


polls/models.py¶
from django.db import models

class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text

class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text
		
		

Важно добавить методы __str__() в ваши модели, не только для вашего удобства при работе с интерактивным приглашением,
но и потому, что представления объектов используются во всех автоматически сгенерированных страниц админки Django.



__________________________________________________________________________________________________________________________________________________

__________________________________________________________________________________________________________________________________________________


Давайте также добавим пользовательский метод к этой модели:

polls/models.py¶
import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
		

Обратите внимание на добавление datetime и from django.utils import timezone для ссылки на стандартный модуль
Python datetime и утилиты Django, связанные с часовыми поясами, в django.utils.timezone соответственно.
Если вы не знакомы с обработкой часовых поясов в Python, вы можете узнать больше в поддержка часовых поясов.



__________________________________________________________________________________________________________________________________________________

__________________________________________________________________________________________________________________________________________________


Сохраните эти изменения и запустите новую интерактивную оболочку Python,

снова запустив python manage.py shell:



>>> from polls.models import Choice, Question

# Make sure our __str__() addition worked.
>>> Question.objects.all()
<QuerySet [<Question: What's up?>]>

# Django provides a rich database lookup API that's entirely driven by
# keyword arguments.
>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith='What')
<QuerySet [<Question: What's up?>]>

# Get the question that was published this year.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

# Request an ID that doesn't exist, this will raise an exception.
>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# Lookup by a primary key is the most common case, so Django provides a
# shortcut for primary-key exact lookups.
# The following is identical to Question.objects.get(id=1).
>>> Question.objects.get(pk=1)
<Question: What's up?>

# Make sure our custom method worked.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# Give the Question a couple of Choices. The create call constructs a new
# Choice object, does the INSERT statement, adds the choice to the set
# of available choices and returns the new Choice object. Django creates
# a set to hold the "other side" of a ForeignKey relation
# (e.g. a question's choice) which can be accessed via the API.
>>> q = Question.objects.get(pk=1)

# Display any choices from the related object set -- none so far.
>>> q.choice_set.all()
<QuerySet []>

# Create three choices.
>>> q.choice_set.create(choice_text='Not much', votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text='The sky', votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)

# Choice objects have API access to their related Question objects.
>>> c.question
<Question: What's up?>

# And vice versa: Question objects get access to Choice objects.
>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

# The API automatically follows relationships as far as you need.
# Use double underscores to separate relationships.
# This works as many levels deep as you want; there's no limit.
# Find all Choices for any question whose pub_date is in this year
# (reusing the 'current_year' variable we created above).
>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

# Let's delete one of the choices. Use delete() for that.
>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
>>> c.delete()


Для получения дополнительной информации о связях в моделях смотрите Доступ к связанным объектам.

Подробнее о том, как использовать двойные подчеркивания для поиска полей через API, смотрите Поиск по полям.
Для получения полной информации об API базы данных, смотрите наш Справочник по API базы данных.


__________________________________________________________________________________________________________________________________________________



__________________________________________________________________________________________________________________________________________________





Административная часть Django¶
Философия

Создание сайтов администратора для ваших сотрудников или клиентов для добавления, изменения и удаления контента - это утомительная работа,
которая не требует большого творческого подхода. По этой причине Django полностью автоматизирует создание интерфейсов администратора для моделей.

Django был написан в новостной среде с очень четким разделением между «издателями контента» и «публичным» сайтом.
Менеджеры сайтов используют систему для добавления новостей, событий, спортивных результатов и т.п. И этот контент отображается на общедоступном сайте.
Django решает проблему создания единого интерфейса для администраторов сайтов для редактирования контента.

Администраторская часть не предназначена для использования посетителями сайта. Это для менеджеров.



__________________________________________________________________________________________________________________________________________________


__________________________________________________________________________________________________________________________________________________




Создание пользователя с правами администратора¶
Сначала нам нужно создать пользователя, который сможет войти на сайт администратора. Запустите следующую команду:



/ 
$ python manage.py createsuperuser

Введите желаемое имя пользователя и нажмите ввод.

Username: admin

Вам будет предложено указать желаемый адрес электронной почты:

Email address: admin@example.com

Последний шаг - ввести ваш пароль. Вам будет предложено ввести пароль дважды, второй раз в качестве подтверждения первого.


Password: **********
Password (again): *********
Superuser created successfully.
Запуск сервера разработки¶


Сайт администратора Django активирован по умолчанию. Давайте запустим сервер разработки и исследуем его.

Если сервер не работает, запустите его так:

/ 
$ python manage.py runserver
Теперь откройте веб-браузер и перейдите по ссылке «/admin/» в локальном домене - например,

http://127.0.0.1:8000/admin/. Вы должны увидеть экран входа администратора:

Django admin login screen
Поскольку перевод включен по умолчанию, если вы установите LANGUAGE_CODE, экран входа будет отображаться на заданном языке
(если у Django есть соответствующие переводы).

Вход в админку¶
Теперь попробуйте войти в систему с учетной записью суперпользователя, которую вы создали на предыдущем шаге.
Вы должны увидеть главную страницу админки Django:

Django admin index page
Вы должны увидеть несколько типов редактируемого контента: группы и пользователи.
Они предоставляются django.contrib.auth, инфраструктурой аутентификации, поставляемой Django.




__________________________________________________________________________________________________________________________________________________


__________________________________________________________________________________________________________________________________________________



Добавление своего приложения в админку¶

Но где наше приложение для голосования? Оно не отображается на главной странице админки.


Осталось сделать еще одно дело: нужно сообщить админке, что у объектов Question есть интерфейс администратора.
Для этого откройте файл polls/admin.py и отредактируйте его следующим образом:


polls/admin.py¶
from django.contrib import admin

from .models import Question

admin.site.register(Question)


__________________________________________________________________________________________________________________________________________________



__________________________________________________________________________________________________________________________________________________



Создание первого приложения на Django, часть 3¶

Этот учебник продолжает вас знакомить с Django с места, где мы остановились в Tutorial 2. Мы продолжаем приложение Web-poll и
сосредоточимся на создании открытого интерфейса - «представлений».





__________________________________________________________________________________________________________________________________________________


Быстрый обзор¶

Представление – это «тип» веб-страницы в приложении Django, которая обычно выполняет определенную функцию и имеет определенный шаблон.
Например, в приложении блога у вас могут быть следующие представления:

Домашняя страница блога - отображает последние записи.
Страница «Детализация» - отдельная страница одной записи.
Страница архива на основе года - отображает все месяцы с записями в данном году.
Страница архива на основе месяца - отображает все дни с записями в данном месяце.
Дневная архивная страница - отображает все записи за данный день.
Действия с комментариями - обрабатывает размещение комментариев к данной записи.
В нашем приложении для опроса будут следующие четыре представления:

Главная страница вопросов - отображает последние несколько вопросов.
Страница вопроса - отображает текст вопроса, без результатов, но с формой для голосования.
Страница результатов вопроса - отображает результаты для конкретного вопроса.
Голосования - обрабатывает голосование за определенный выбор в конкретном вопросе.
В Django веб-страницы и другой контент доставляются по представлениям. Каждое представление представлено функцией Python
(или методом в случае представлений на основе классов). Django выберет представление, изучив запрашиваемый URL (точнее, часть URL после имени домена).


Теперь, находясь в Интернете, вы можете встретить такую красоту, как «ME2/Sites/dirmod.asp?sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B».
Вам будет приятно узнать, что Django позволяет создавать гораздо более элегантные шаблоны URL.

Шаблон URL - это общая форма URL, например: /newsarchive/<year>/<month>/.

Чтобы перейти от URL к представлению, Django использует так называемый URLconfs. URLconf сопоставляет шаблоны URL с представлениями.

Этот учебник содержит основные инструкции по использованию URLconfs, и вы можете обратиться к Диспетчер URL для получения дополнительной информации.




__________________________________________________________________________________________________________________________________________________


__________________________________________________________________________________________________________________________________________________


Написание представлений¶

Теперь давайте добавим еще несколько представлений в polls/views.py. Эти представления немного отличаются, потому что они принимают аргумент:



polls/views.py¶
def detail(request, question_id):
    return HttpResponse("You're looking at question %s." % question_id)

def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)

def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)
	
	
	
__________________________________________________________________________________________________________________________________________________



Подключите эти новые представления в модуль polls.urls, добавив следующие path() вызовы:



polls/urls.py¶
from django.urls import path

from . import views

urlpatterns = [
    # ex: /polls/
    path('', views.index, name='index'),
    # ex: /polls/5/
    path('<int:question_id>/', views.detail, name='detail'),
    # ex: /polls/5/results/
    path('<int:question_id>/results/', views.results, name='results'),
    # ex: /polls/5/vote/
    path('<int:question_id>/vote/', views.vote, name='vote'),
]



Перейдите в браузере по адресу «/polls/34/». Он запустит метод detail() и отобразит любой идентификатор,
который вы указали в URL. Попробуйте также «/polls/34/results/» и «/polls/34/vote/» - они отобразят результаты и страницы голосования.




__________________________________________________________________________________________________________________________________________________


__________________________________________________________________________________________________________________________________________________


Когда кто-то запрашивает страницу с вашего сайта - скажем, «/polls/34/», Django загрузит модуль Python mysite.urls,
поскольку на него указывает параметр ROOT_URLCONF. Он находит переменную с именем `` urlpatterns`` и просматривает шаблоны по порядку.
После нахождения соответствия в 'polls/' ``, он убирает соответствующий текст («polls/») и
отправляет оставшийся текст - ``"34/" - в „polls.urls“ URLconf для дальнейшей обработки. Там он соответствует '<int:question_id>/',
что приводит к вызову представления detail() следующим образом:

detail(request=<HttpRequest object>, question_id=34)


Часть question_id=34 взята из <int:question_id>. Использование угловых скобок «захватывает» часть URL и отправляет ее
в качестве ключевого аргумента в функцию представления. Часть строки :question_id> определяет имя, которое будет использоваться для
идентификации сопоставленного шаблона, а часть <int: - это преобразователь, который определяет, какие шаблоны должны соответствовать этой части пути URL.




__________________________________________________________________________________________________________________________________________________

__________________________________________________________________________________________________________________________________________________







